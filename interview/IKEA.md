# IKEA

## HTML5 离线存储

工作原理：

> 当用户没有网络时，用户可以正常访问站点，当用户连接网络时，更新站点存储相关资源。html5 离线存储基于一个新建的 manifest 文件的缓存机制，根据这个文件的解析清单，缓存相关站点资源，这些资源就想 cookie 一样被存储下来，用户离线的时候加载离线数据

使用方式：在页面头部加一个 manifest 属性，使用`navigator.onLine == true`来判断是否正常联网

离线存储技术，Application Cache 带来的三个优势是：

- 离线浏览
- 提升页面载入速度
- 降低服务器压力

## Differ of Angular1 and Angular2

1. 编程语言的不同。angular1.x 是 JavaScript，可以直接在浏览器中运行，而 angular2 是 TypeScript,只有经过编译后才能在浏览器中运行，所以它必须使用构建工具。
2. 控制器 Controller 的改变。在 1 中它是非常重要的，用于封装视图控制逻辑，而 2 中这个，开发模式改为了模块化开发，去除了它。
3. 作用域 Scope。在 2 中没有\$Scope,它使用 zone.js 来记录监测变化；
4. 指令。在 2 中指令使用符号，例如：ngFor、\*ngIf；指令不能直接嵌套使用，所以它增加了一个`<ng-container></ng-container>`标签来包裹指令。
5. 过滤器。1 用：filter。在 2 中名字改为了 Pipe,增加 asyc、slice、parcent。
6. 依赖注入。在 2 中只有一个依赖注入机制。
7. 组件生命周期。1 中没有明确的生命周期机制。在 2 中有精心设计的生命周期
8. 双向数据绑定。[(ngModel)]的写法替换了 ng-model。

## VUE

### 双向绑定是如何实现的

### Computed v.s. Watch

- Computed

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed
5. 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。

- Watch

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch 支持异步；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；
5. 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，

   - immediate：组件加载立即触发回调函数执行，

   - deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。

### VNode of Vue

vnode只是一个名字，本质上来说就是一个普通的JavaScript对象，是从VNode类实例化的对象。我们用这个JavaScript对象来描述一个真实DOM元素的话，那么该DOM元素上的所有属性在VNode这个对象上都存在对应得属性。

vnode和视图是一一对应的。我们可以把vnode理解成JavaScript对象版本的DOM元素。渲染视图的过程是先创建vnode，然后在使用vnode去生成真实的DOM元素，最后插入到页面渲染视图。

VNode作用：将上一次渲染视图时先所创建的vnode先缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode对比，查看他们之间有哪些不一样的地方，找出不一样的地方并基于此去修改真实的DOM。

对vnode实现了缓存，将上一次的缓存和当前创建的vnode对比，只更新有差异的节点就变得很重要。这也是vnode最重要的一个作用。
